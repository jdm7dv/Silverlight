/*
 * Automatically generated, do not edit this file directly
 */

#include <config.h>

#include <stdio.h>
#include <stdlib.h>

#include "cbinding.h"

#include "animation.h"
#include "application.h"
#include "bitmapcache.h"
#include "bitmapimage.h"
#include "bitmapsource.h"
#include "border.h"
#include "brush.h"
#include "canvas.h"
#include "collection.h"
#include "contentcontrol.h"
#include "control.h"
#include "deepzoomimagetilesource.h"
#include "dependencyobject.h"
#include "dependencyproperty.h"
#include "deployment.h"
#include "downloader.h"
#include "easing.h"
#include "effect.h"
#include "eventargs.h"
#include "frameworkelement.h"
#include "geometry.h"
#include "glyphs.h"
#include "grid.h"
#include "imagesource.h"
#include "keyboard.h"
#include "media.h"
#include "mediaelement.h"
#include "multiscaleimage.h"
#include "multiscalesubimage.h"
#include "namescope.h"
#include "panel.h"
#include "pipeline.h"
#include "popup.h"
#include "projection.h"
#include "resources.h"
#include "runtime.h"
#include "shape.h"
#include "size.h"
#include "style.h"
#include "stylus.h"
#include "tabnavigationwalker.h"
#include "template.h"
#include "textblock.h"
#include "textbox.h"
#include "tilesource.h"
#include "timeline.h"
#include "timemanager.h"
#include "transform.h"
#include "trigger.h"
#include "type.h"
#include "uielement.h"
#include "uri.h"
#include "usercontrol.h"
#include "window.h"
#include "window-gtk.h"
#include "writeablebitmap.h"
#include "xaml.h"
#include "xap.h"
/**
 * Application
 **/
Application *
application_new (void)
{
	return new Application ();
}


Application *
application_get_current (void)
{
	return Application::GetCurrent ();
}


void
application_register_callbacks (Application *instance, ApplyDefaultStyleCallback apply_default_style_cb, ApplyStyleCallback apply_style_cb, GetResourceCallback get_resource_cb, ConvertKeyframeValueCallback convert_keyframe_callback)
{
	if (instance == NULL)
		return;
	
	instance->RegisterCallbacks (apply_default_style_cb, apply_style_cb, get_resource_cb, convert_keyframe_callback);
}


void
application_set_current (Application *current)
{
	Application::SetCurrent (current);
}


/**
 * ArcSegment
 **/
ArcSegment *
arc_segment_new (void)
{
	return new ArcSegment ();
}


/**
 * AssemblyPart
 **/
AssemblyPart *
assembly_part_new (void)
{
	return new AssemblyPart ();
}


/**
 * AssemblyPartCollection
 **/
AssemblyPartCollection *
assembly_part_collection_new (void)
{
	return new AssemblyPartCollection ();
}


/**
 * AudioStream
 **/
AudioStream *
audio_stream_new (Media *media, int codec_id, int bits_per_sample, int block_align, int sample_rate, int channels, int bit_rate, gpointer extra_data, guint32 extra_data_size)
{
	return new AudioStream (media, codec_id, bits_per_sample, block_align, sample_rate, channels, bit_rate, extra_data, extra_data_size);
}


int
audio_stream_get_bit_rate (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetBitRate ();
}


int
audio_stream_get_bits_per_sample (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetBitsPerSample ();
}


int
audio_stream_get_block_align (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetBlockAlign ();
}


int
audio_stream_get_channels (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetChannels ();
}


int
audio_stream_get_input_bit_rate (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetInputBitRate ();
}


int
audio_stream_get_input_bits_per_sample (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetInputBitsPerSample ();
}


int
audio_stream_get_input_block_align (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetInputBlockAlign ();
}


int
audio_stream_get_input_channels (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetInputChannels ();
}


int
audio_stream_get_input_sample_rate (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetInputSampleRate ();
}


int
audio_stream_get_output_bit_rate (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetOutputBitRate ();
}


int
audio_stream_get_output_bits_per_sample (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetOutputBitsPerSample ();
}


int
audio_stream_get_output_block_align (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetOutputBlockAlign ();
}


int
audio_stream_get_output_channels (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetOutputChannels ();
}


int
audio_stream_get_output_sample_rate (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetOutputSampleRate ();
}


int
audio_stream_get_sample_rate (AudioStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetSampleRate ();
}


void
audio_stream_set_bit_rate (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetBitRate (value);
}


void
audio_stream_set_bits_per_sample (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetBitsPerSample (value);
}


void
audio_stream_set_block_align (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetBlockAlign (value);
}


void
audio_stream_set_channels (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetChannels (value);
}


void
audio_stream_set_input_bit_rate (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetInputBitRate (value);
}


void
audio_stream_set_input_bits_per_sample (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetInputBitsPerSample (value);
}


void
audio_stream_set_input_block_align (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetInputBlockAlign (value);
}


void
audio_stream_set_input_channels (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetInputChannels (value);
}


void
audio_stream_set_input_sample_rate (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetInputSampleRate (value);
}


void
audio_stream_set_output_bit_rate (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetOutputBitRate (value);
}


void
audio_stream_set_output_bits_per_sample (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetOutputBitsPerSample (value);
}


void
audio_stream_set_output_block_align (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetOutputBlockAlign (value);
}


void
audio_stream_set_output_channels (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetOutputChannels (value);
}


void
audio_stream_set_output_sample_rate (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetOutputSampleRate (value);
}


void
audio_stream_set_sample_rate (AudioStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetSampleRate (value);
}


/**
 * BackEase
 **/
BackEase *
back_ease_new (void)
{
	return new BackEase ();
}


double
back_ease_ease_in_core (BackEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


/**
 * BeginStoryboard
 **/
BeginStoryboard *
begin_storyboard_new (void)
{
	return new BeginStoryboard ();
}


/**
 * BezierSegment
 **/
BezierSegment *
bezier_segment_new (void)
{
	return new BezierSegment ();
}


/**
 * BitmapCache
 **/
BitmapCache *
bitmap_cache_new (void)
{
	return new BitmapCache ();
}


/**
 * BitmapImage
 **/
BitmapImage *
bitmap_image_new (void)
{
	return new BitmapImage ();
}


void
bitmap_image_pixbuf_write (BitmapImage *instance, gpointer buffer, gint32 offset, gint32 n)
{
	if (instance == NULL)
		return;
	
	instance->PixbufWrite (buffer, offset, n);
}


void
bitmap_image_pixmap_complete (BitmapImage *instance)
{
	if (instance == NULL)
		return;
	
	instance->PixmapComplete ();
}


/**
 * BitmapSource
 **/
BitmapSource *
bitmap_source_new (void)
{
	return new BitmapSource ();
}


gpointer
bitmap_source_get_bitmap_data (BitmapSource *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (gpointer) 0;
	
	return instance->GetBitmapData ();
}


void
bitmap_source_invalidate (BitmapSource *instance)
{
	if (instance == NULL)
		return;
	
	instance->Invalidate ();
}


void
bitmap_source_set_bitmap_data (BitmapSource *instance, gpointer data, bool own)
{
	if (instance == NULL)
		return;
	
	instance->SetBitmapData (data, own);
}


/**
 * BlurEffect
 **/
BlurEffect *
blur_effect_new (void)
{
	return new BlurEffect ();
}


/**
 * Border
 **/
Border *
border_new (void)
{
	return new Border ();
}


/**
 * BounceEase
 **/
BounceEase *
bounce_ease_new (void)
{
	return new BounceEase ();
}


double
bounce_ease_ease_in_core (BounceEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


/**
 * Brush
 **/
Brush *
brush_new (void)
{
	return new Brush ();
}


/**
 * CacheMode
 **/
CacheMode *
cache_mode_new (void)
{
	return new CacheMode ();
}


/**
 * Canvas
 **/
Canvas *
canvas_new (void)
{
	return new Canvas ();
}


/**
 * CircleEase
 **/
CircleEase *
circle_ease_new (void)
{
	return new CircleEase ();
}


double
circle_ease_ease_in_core (CircleEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


/**
 * Collection
 **/
int
collection_add_with_error (Collection *instance, Value *value, MoonError *error)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_add_with_error () with error == NULL.");
	return instance->AddWithError (value, error);
}


bool
collection_clear (Collection *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->Clear ();
}


bool
collection_contains (Collection *instance, Value *value)
{
	if (instance == NULL)
		return false;
	
	return instance->Contains (value);
}


int
collection_get_count (Collection *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetCount ();
}


int
collection_get_element_type (Collection *instance)
{
	if (instance == NULL)
		return Type::INVALID;
	
	return instance->GetElementType ();
}


CollectionIterator *
collection_get_iterator (Collection *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetIterator ();
}


Value *
collection_get_value_at_with_error (Collection *instance, int index, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_get_value_at_with_error () with error == NULL.");
	return instance->GetValueAtWithError (index, error);
}


int
collection_index_of (Collection *instance, Value *value)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->IndexOf (value);
}


bool
collection_insert_with_error (Collection *instance, int index, Value *value, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_insert_with_error () with error == NULL.");
	return instance->InsertWithError (index, value, error);
}


bool
collection_remove (Collection *instance, Value *value)
{
	if (instance == NULL)
		return false;
	
	return instance->Remove (value);
}


bool
collection_remove_at_with_error (Collection *instance, int index, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_remove_at_with_error () with error == NULL.");
	return instance->RemoveAtWithError (index, error);
}


bool
collection_set_value_at_with_error (Collection *instance, int index, Value *value, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_set_value_at_with_error () with error == NULL.");
	return instance->SetValueAtWithError (index, value, error);
}


/**
 * CollectionChangedEventArgs
 **/
CollectionChangedEventArgs *
collection_changed_event_args_new (void)
{
	return new CollectionChangedEventArgs ();
}


int
collection_changed_event_args_get_changed_action (CollectionChangedEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (CollectionChangedAction) 0;
	
	return instance->GetChangedAction ();
}


int
collection_changed_event_args_get_index (CollectionChangedEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetIndex ();
}


Value *
collection_changed_event_args_get_new_item (CollectionChangedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetNewItem ();
}


Value *
collection_changed_event_args_get_old_item (CollectionChangedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetOldItem ();
}


void
collection_changed_event_args_set_changed_action (CollectionChangedEventArgs *instance, int action)
{
	if (instance == NULL)
		return;
	
	instance->SetChangedAction ((CollectionChangedAction) action);
}


void
collection_changed_event_args_set_index (CollectionChangedEventArgs *instance, int index)
{
	if (instance == NULL)
		return;
	
	instance->SetIndex (index);
}


void
collection_changed_event_args_set_new_item (CollectionChangedEventArgs *instance, Value *item)
{
	if (instance == NULL)
		return;
	
	instance->SetNewItem (item);
}


void
collection_changed_event_args_set_old_item (CollectionChangedEventArgs *instance, Value *item)
{
	if (instance == NULL)
		return;
	
	instance->SetOldItem (item);
}


/**
 * CollectionIterator
 **/
void
collection_iterator_destroy (CollectionIterator *iterator)
{
	CollectionIterator::Destroy (iterator);
}


Value *
collection_iterator_get_current (CollectionIterator *instance, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_iterator_get_current () with error == NULL.");
	return instance->GetCurrent (error);
}


bool
collection_iterator_next (CollectionIterator *instance, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called collection_iterator_next () with error == NULL.");
	return instance->Next (error);
}


bool
collection_iterator_reset (CollectionIterator *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->Reset ();
}


/**
 * ColorAnimation
 **/
ColorAnimation *
color_animation_new (void)
{
	return new ColorAnimation ();
}


/**
 * ColorAnimationUsingKeyFrames
 **/
ColorAnimationUsingKeyFrames *
color_animation_using_key_frames_new (void)
{
	return new ColorAnimationUsingKeyFrames ();
}


/**
 * ColorKeyFrame
 **/
ColorKeyFrame *
color_key_frame_new (void)
{
	return new ColorKeyFrame ();
}


/**
 * ColorKeyFrameCollection
 **/
ColorKeyFrameCollection *
color_key_frame_collection_new (void)
{
	return new ColorKeyFrameCollection ();
}


/**
 * ColumnDefinition
 **/
ColumnDefinition *
column_definition_new (void)
{
	return new ColumnDefinition ();
}


/**
 * ColumnDefinitionCollection
 **/
ColumnDefinitionCollection *
column_definition_collection_new (void)
{
	return new ColumnDefinitionCollection ();
}


/**
 * ContentChangedEventArgs
 **/
Value *
content_changed_event_args_get_new_content (ContentChangedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetNewContent ();
}


Value *
content_changed_event_args_get_old_content (ContentChangedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetOldContent ();
}


/**
 * ContentControl
 **/
ContentControl *
content_control_new (void)
{
	return new ContentControl ();
}


bool
content_control_get_content_sets_parent (ContentControl *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->GetContentSetsParent ();
}


void
content_control_set_content_sets_parent (ContentControl *instance, bool value)
{
	if (instance == NULL)
		return;
	
	instance->SetContentSetsParent (value);
}


/**
 * Control
 **/
Control *
control_new (void)
{
	return new Control ();
}


DependencyObject *
control_get_template_child (Control *instance, const char *name)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTemplateChild (name);
}


/**
 * ControlTemplate
 **/
ControlTemplate *
control_template_new (void)
{
	return new ControlTemplate ();
}


/**
 * CubicEase
 **/
CubicEase *
cubic_ease_new (void)
{
	return new CubicEase ();
}


double
cubic_ease_ease_in_core (CubicEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


/**
 * CursorPositionChangedEventArgs
 **/
CursorPositionChangedEventArgs *
cursor_position_changed_event_args_new (void)
{
	return new CursorPositionChangedEventArgs ();
}


double
cursor_position_changed_event_args_get_cursor_height (CursorPositionChangedEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetCursorHeight ();
}


double
cursor_position_changed_event_args_get_cursor_x (CursorPositionChangedEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetCursorX ();
}


double
cursor_position_changed_event_args_get_cursor_y (CursorPositionChangedEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetCursorY ();
}


/**
 * DataTemplate
 **/
DataTemplate *
data_template_new (void)
{
	return new DataTemplate ();
}


/**
 * DeepZoomImageTileSource
 **/
DeepZoomImageTileSource *
deep_zoom_image_tile_source_new (void)
{
	return new DeepZoomImageTileSource ();
}


/**
 * DependencyObject
 **/
void
dependency_object_add_property_change_handler (DependencyObject *instance, DependencyProperty *property, PropertyChangeHandler cb, gpointer closure)
{
	if (instance == NULL)
		return;
	
	instance->AddPropertyChangeHandler (property, cb, closure);
}


void
dependency_object_clear_value (DependencyObject *instance, DependencyProperty *property, bool notify_listeners, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_clear_value () with error == NULL.");
	instance->ClearValue (property, notify_listeners, error);
}


DependencyObject *
dependency_object_new (void)
{
	return new DependencyObject ();
}


DependencyObject *
dependency_object_find_name (DependencyObject *instance, const char *name, int *element_kind)
{
	if (instance == NULL)
		return NULL;
	
	return instance->FindName (name, (Type::Kind*) element_kind);
}


const char *
dependency_object_get_name (DependencyObject *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetName ();
}


DependencyObject *
dependency_object_get_template_owner (DependencyObject *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTemplateOwner ();
}


Value *
dependency_object_get_value_no_default_with_error (DependencyObject *instance, DependencyProperty *property, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_get_value_no_default_with_error () with error == NULL.");
	return instance->GetValueNoDefaultWithError (property, error);
}


Value *
dependency_object_get_value_with_error (DependencyObject *instance, int whatami, DependencyProperty *property, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_get_value_with_error () with error == NULL.");
	return instance->GetValueWithError ((Type::Kind) whatami, property, error);
}


Value *
dependency_object_read_local_value_with_error (DependencyObject *instance, DependencyProperty *property, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_read_local_value_with_error () with error == NULL.");
	return instance->ReadLocalValueWithError (property, error);
}


void
dependency_object_remove_property_change_handler (DependencyObject *instance, DependencyProperty *property, PropertyChangeHandler cb)
{
	if (instance == NULL)
		return;
	
	instance->RemovePropertyChangeHandler (property, cb);
}


void
dependency_object_set_name (DependencyObject *instance, const char *name)
{
	if (instance == NULL)
		return;
	
	instance->SetName (name);
}


void
dependency_object_set_parent (DependencyObject *instance, DependencyObject *parent, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_set_parent () with error == NULL.");
	instance->SetParent (parent, error);
}


void
dependency_object_set_template_owner (DependencyObject *instance, DependencyObject *value)
{
	if (instance == NULL)
		return;
	
	instance->SetTemplateOwner (value);
}


bool
dependency_object_set_value_with_error (DependencyObject *instance, DependencyProperty *property, Value *value, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called dependency_object_set_value_with_error () with error == NULL.");
	return instance->SetValueWithError (property, value, error);
}


/**
 * DependencyObjectCollection
 **/
DependencyObjectCollection *
dependency_object_collection_new (void)
{
	return new DependencyObjectCollection ();
}


/**
 * DependencyProperty
 **/
Value *
dependency_property_get_default_value (DependencyProperty *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetDefaultValue ();
}


DependencyProperty *
dependency_property_get_dependency_property (int type, const char *name)
{
	return DependencyProperty::GetDependencyProperty ((Type::Kind) type, name);
}


DependencyProperty *
dependency_property_get_dependency_property_full (int type, const char *name, bool inherits)
{
	return DependencyProperty::GetDependencyPropertyFull ((Type::Kind) type, name, inherits);
}


const char *
dependency_property_get_name (DependencyProperty *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetName ();
}


int
dependency_property_get_property_type (DependencyProperty *instance)
{
	if (instance == NULL)
		return Type::INVALID;
	
	return instance->GetPropertyType ();
}


bool
dependency_property_is_attached (DependencyProperty *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->IsAttached ();
}


bool
dependency_property_is_nullable (DependencyProperty *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->IsNullable ();
}


bool
dependency_property_is_read_only (DependencyProperty *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->IsReadOnly ();
}


DependencyProperty *
dependency_property_register_core_property (const char *name, int property_type, int owner_type, Value *defaultValue, bool attached, bool read_only, PropertyChangeHandler callback)
{
	return DependencyProperty::RegisterCoreProperty (name, (Type::Kind) property_type, (Type::Kind) owner_type, defaultValue, attached, read_only, callback);
}


DependencyProperty *
dependency_property_register_custom_property (const char *name, int property_type, int owner_type, Value *defaultValue, bool attached, bool read_only, PropertyChangeHandler callback)
{
	return DependencyProperty::RegisterCustomProperty (name, (Type::Kind) property_type, (Type::Kind) owner_type, defaultValue, attached, read_only, callback);
}


void
dependency_property_set_is_nullable (DependencyProperty *instance, bool value)
{
	if (instance == NULL)
		return;
	
	instance->SetIsNullable (value);
}


void
dependency_property_set_property_changed_callback (DependencyProperty *instance, PropertyChangeHandler changed_callback)
{
	if (instance == NULL)
		return;
	
	instance->SetPropertyChangedCallback (changed_callback);
}


/**
 * Deployment
 **/
Deployment *
deployment_new (void)
{
	return new Deployment ();
}


Deployment *
deployment_get_current (void)
{
	return Deployment::GetCurrent ();
}


Types *
deployment_get_types (Deployment *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTypes ();
}


void
deployment_set_current (Deployment *value)
{
	Deployment::SetCurrent (value);
}


void
deployment_set_current_application (Deployment *instance, Application *value)
{
	if (instance == NULL)
		return;
	
	instance->SetCurrentApplication (value);
}


void
deployment_set_is_loaded_from_xap (Deployment *instance, bool flag)
{
	if (instance == NULL)
		return;
	
	instance->SetIsLoadedFromXap (flag);
}


/**
 * DiscreteColorKeyFrame
 **/
DiscreteColorKeyFrame *
discrete_color_key_frame_new (void)
{
	return new DiscreteColorKeyFrame ();
}


/**
 * DiscreteDoubleKeyFrame
 **/
DiscreteDoubleKeyFrame *
discrete_double_key_frame_new (void)
{
	return new DiscreteDoubleKeyFrame ();
}


/**
 * DiscreteObjectKeyFrame
 **/
DiscreteObjectKeyFrame *
discrete_object_key_frame_new (void)
{
	return new DiscreteObjectKeyFrame ();
}


/**
 * DiscretePointKeyFrame
 **/
DiscretePointKeyFrame *
discrete_point_key_frame_new (void)
{
	return new DiscretePointKeyFrame ();
}


/**
 * DispatcherTimer
 **/
DispatcherTimer *
dispatcher_timer_new (void)
{
	return new DispatcherTimer ();
}


void
dispatcher_timer_start (DispatcherTimer *instance)
{
	if (instance == NULL)
		return;
	
	instance->Start ();
}


void
dispatcher_timer_stop (DispatcherTimer *instance)
{
	if (instance == NULL)
		return;
	
	instance->Stop ();
}


/**
 * DoubleAnimation
 **/
DoubleAnimation *
double_animation_new (void)
{
	return new DoubleAnimation ();
}


/**
 * DoubleAnimationUsingKeyFrames
 **/
DoubleAnimationUsingKeyFrames *
double_animation_using_key_frames_new (void)
{
	return new DoubleAnimationUsingKeyFrames ();
}


/**
 * DoubleCollection
 **/
DoubleCollection *
double_collection_new (void)
{
	return new DoubleCollection ();
}


/**
 * DoubleKeyFrame
 **/
DoubleKeyFrame *
double_key_frame_new (void)
{
	return new DoubleKeyFrame ();
}


/**
 * DoubleKeyFrameCollection
 **/
DoubleKeyFrameCollection *
double_key_frame_collection_new (void)
{
	return new DoubleKeyFrameCollection ();
}


/**
 * Downloader
 **/
void *
downloader_create_web_request (Downloader *instance, const char *method, const char *uri)
{
	if (instance == NULL)
		return NULL;
	
	return instance->CreateWebRequest (method, uri);
}


Downloader *
downloader_new (void)
{
	return new Downloader ();
}


void
downloader_notify_failed (Downloader *instance, const char *msg)
{
	if (instance == NULL)
		return;
	
	instance->NotifyFailed (msg);
}


void
downloader_notify_finished (Downloader *instance, const char *final_uri)
{
	if (instance == NULL)
		return;
	
	instance->NotifyFinished (final_uri);
}


void
downloader_notify_size (Downloader *instance, gint64 size)
{
	if (instance == NULL)
		return;
	
	instance->NotifySize (size);
}


void
downloader_set_functions (DownloaderCreateStateFunc create_state, DownloaderDestroyStateFunc destroy_state, DownloaderOpenFunc open, DownloaderSendFunc send, DownloaderAbortFunc abort, DownloaderHeaderFunc header, DownloaderBodyFunc body, DownloaderCreateWebRequestFunc request, DownloaderSetResponseHeaderCallbackFunc response_header_callback, DownloaderGetResponseFunc get_response)
{
	Downloader::SetFunctions (create_state, destroy_state, open, send, abort, header, body, request, response_header_callback, get_response);
}


void
downloader_write (Downloader *instance, void *buf, gint32 offset, gint32 n)
{
	if (instance == NULL)
		return;
	
	instance->Write (buf, offset, n);
}


/**
 * DownloaderRequest
 **/
void
downloader_request_free (DownloaderRequest *instance)
{
	delete instance;
}


void
downloader_request_abort (DownloaderRequest *instance)
{
	if (instance == NULL)
		return;
	
	instance->Abort ();
}


DownloaderResponse *
downloader_request_get_downloader_response (DownloaderRequest *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetDownloaderResponse ();
}


bool
downloader_request_get_response (DownloaderRequest *instance, DownloaderResponseStartedHandler started, DownloaderResponseDataAvailableHandler available, DownloaderResponseFinishedHandler finished, gpointer context)
{
	if (instance == NULL)
		return false;
	
	return instance->GetResponse (started, available, finished, context);
}


const bool
downloader_request_is_aborted (DownloaderRequest *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->IsAborted ();
}


void
downloader_request_set_body (DownloaderRequest *instance, void *body, int size)
{
	if (instance == NULL)
		return;
	
	instance->SetBody (body, size);
}


void
downloader_request_set_http_header (DownloaderRequest *instance, const char *name, const char *value)
{
	if (instance == NULL)
		return;
	
	instance->SetHttpHeader (name, value);
}


/**
 * DownloaderResponse
 **/
void
downloader_response_free (DownloaderResponse *instance)
{
	delete instance;
}


void
downloader_response_abort (DownloaderResponse *instance)
{
	if (instance == NULL)
		return;
	
	instance->Abort ();
}


int
downloader_response_get_response_status (DownloaderResponse *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetResponseStatus ();
}


const char *
downloader_response_get_response_status_text (DownloaderResponse *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetResponseStatusText ();
}


void
downloader_response_set_header_visitor (DownloaderResponse *instance, DownloaderResponseHeaderCallback visitor, gpointer context)
{
	if (instance == NULL)
		return;
	
	instance->SetHeaderVisitor (visitor, context);
}


/**
 * DownloadProgressEventArgs
 **/
double
download_progress_event_args_get_progress (DownloadProgressEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetProgress ();
}


/**
 * DrawingAttributes
 **/
DrawingAttributes *
drawing_attributes_new (void)
{
	return new DrawingAttributes ();
}


/**
 * DropShadowEffect
 **/
DropShadowEffect *
drop_shadow_effect_new (void)
{
	return new DropShadowEffect ();
}


/**
 * EasingColorKeyFrame
 **/
EasingColorKeyFrame *
easing_color_key_frame_new (void)
{
	return new EasingColorKeyFrame ();
}


/**
 * EasingDoubleKeyFrame
 **/
EasingDoubleKeyFrame *
easing_double_key_frame_new (void)
{
	return new EasingDoubleKeyFrame ();
}


/**
 * EasingFunctionBase
 **/
EasingFunctionBase *
easing_function_base_new (void)
{
	return new EasingFunctionBase ();
}


void
easing_function_base_set_easing_function (EasingFunctionBase *instance, EasingFunction value)
{
	if (instance == NULL)
		return;
	
	instance->SetEasingFunction (value);
}


/**
 * EasingPointKeyFrame
 **/
EasingPointKeyFrame *
easing_point_key_frame_new (void)
{
	return new EasingPointKeyFrame ();
}


/**
 * Effect
 **/
Effect *
effect_new (void)
{
	return new Effect ();
}


/**
 * ElasticEase
 **/
double
elastic_ease_ease_in_core (ElasticEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


ElasticEase *
elastic_ease_new (void)
{
	return new ElasticEase ();
}


/**
 * Ellipse
 **/
Ellipse *
ellipse_new (void)
{
	return new Ellipse ();
}


/**
 * EllipseGeometry
 **/
EllipseGeometry *
ellipse_geometry_new (void)
{
	return new EllipseGeometry ();
}


/**
 * ErrorEventArgs
 **/
int
error_event_args_get_error_code (ErrorEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetErrorCode ();
}


const char *
error_event_args_get_error_message (ErrorEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetErrorMessage ();
}


int
error_event_args_get_error_type (ErrorEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetErrorType ();
}


gpointer
error_event_args_get_moon_error (ErrorEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (gpointer) 0;
	
	return instance->GetMoonError ();
}


/**
 * EventObject
 **/
int
event_object_add_handler (EventObject *instance, int event_id, EventHandler handler, gpointer data, GDestroyNotify data_dtor)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->AddHandler (event_id, handler, data, data_dtor);
}


void
event_object_add_on_event_handler (EventObject *instance, int event_id, EventHandler handler, gpointer data, GDestroyNotify data_dtor)
{
	if (instance == NULL)
		return;
	
	instance->AddOnEventHandler (event_id, handler, data, data_dtor);
}


void
event_object_add_toggle_ref_notifier (EventObject *instance, ToggleNotifyHandler tr)
{
	if (instance == NULL)
		return;
	
	instance->AddToggleRefNotifier (tr);
}


int
event_object_add_xaml_handler (EventObject *instance, int event_id, EventHandler handler, gpointer data, GDestroyNotify data_dtor)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->AddXamlHandler (event_id, handler, data, data_dtor);
}


void
event_object_do_emit_current_context (EventObject *instance, int event_id, EventArgs *calldata)
{
	if (instance == NULL)
		return;
	
	instance->DoEmitCurrentContext (event_id, calldata);
}


int
event_object_get_object_type (EventObject *instance)
{
	if (instance == NULL)
		return Type::INVALID;
	
	return instance->GetObjectType ();
}


Surface *
event_object_get_surface (EventObject *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetSurface ();
}


const char *
event_object_get_type_name (EventObject *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTypeName ();
}


void
event_object_ref (EventObject *instance)
{
	if (instance == NULL)
		return;
	
	instance->ref ();
}


int
event_object_remove_handler (EventObject *instance, int event_id, EventHandler handler, gpointer data)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->RemoveHandler (event_id, handler, data);
}


void
event_object_remove_on_event_handler (EventObject *instance, int event_id, EventHandler handler, gpointer data)
{
	if (instance == NULL)
		return;
	
	instance->RemoveOnEventHandler (event_id, handler, data);
}


void
event_object_remove_toggle_ref_notifier (EventObject *instance)
{
	if (instance == NULL)
		return;
	
	instance->RemoveToggleRefNotifier ();
}


void
event_object_set_object_type (EventObject *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetObjectType ((Type::Kind) value);
}


void
event_object_unref (EventObject *instance)
{
	if (instance == NULL)
		return;
	
	instance->unref ();
}


/**
 * EventTrigger
 **/
EventTrigger *
event_trigger_new (void)
{
	return new EventTrigger ();
}


/**
 * ExponentialEase
 **/
double
exponential_ease_ease_in_core (ExponentialEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


ExponentialEase *
exponential_ease_new (void)
{
	return new ExponentialEase ();
}


/**
 * ExtensionPart
 **/
ExtensionPart *
extension_part_new (void)
{
	return new ExtensionPart ();
}


/**
 * ExternalDecoder
 **/
ExternalDecoder *
external_decoder_new (Media *media, IMediaStream *stream, void *instance, const char *name, ExternalDecoder_DecodeFrameAsyncCallback decode_frame_async, ExternalDecoder_OpenDecoderAsyncCallback open_decoder_async, ExternalDecoder_CleanupCallback cleanup, ExternalDecoder_CleanStateCallback clean_state, ExternalDecoder_HasDelayedFrameCallback has_delayed_frame, ExternalDecoder_DisposeCallback dispose, ExternalDecoder_DtorCallback dtor)
{
	return new ExternalDecoder (media, stream, instance, name, decode_frame_async, open_decoder_async, cleanup, clean_state, has_delayed_frame, dispose, dtor);
}


/**
 * ExternalDecoderInfo
 **/
ExternalDecoderInfo *
external_decoder_info_new (void *instance, const char *name, ExternalDecoderInfo_SupportsCallback supports, ExternalDecoderInfo_Create create, ExternalDecoderInfo_dtor dtor)
{
	return new ExternalDecoderInfo (instance, name, supports, create, dtor);
}


/**
 * ExternalDemuxer
 **/
gint32
external_demuxer_add_stream (ExternalDemuxer *instance, IMediaStream *stream)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (gint32) 0;
	
	return instance->AddStream (stream);
}


void
external_demuxer_clear_callbacks (ExternalDemuxer *instance)
{
	if (instance == NULL)
		return;
	
	instance->ClearCallbacks ();
}


void
external_demuxer_set_can_seek (ExternalDemuxer *instance, bool value)
{
	if (instance == NULL)
		return;
	
	instance->SetCanSeek (value);
}


/**
 * ExternalPart
 **/
ExternalPart *
external_part_new (void)
{
	return new ExternalPart ();
}


/**
 * ExternalPartCollection
 **/
ExternalPartCollection *
external_part_collection_new (void)
{
	return new ExternalPartCollection ();
}


/**
 * FrameworkElement
 **/
bool
framework_element_apply_template (FrameworkElement *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->ApplyTemplate ();
}


Size
framework_element_arrange_override (FrameworkElement *instance, Size finalSize)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (Size) 0;
	
	return instance->ArrangeOverride (finalSize);
}


FrameworkElement *
framework_element_new (void)
{
	return new FrameworkElement ();
}


DependencyObject *
framework_element_get_logical_parent (FrameworkElement *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetLogicalParent ();
}


Size
framework_element_measure_override (FrameworkElement *instance, Size availableSize)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (Size) 0;
	
	return instance->MeasureOverride (availableSize);
}


void
framework_element_register_managed_overrides (FrameworkElement *instance, MeasureOverrideCallback measure_cb, ArrangeOverrideCallback arrange_cb, GetDefaultTemplateCallback get_default_template_cb, LoadedCallback loaded_cb)
{
	if (instance == NULL)
		return;
	
	instance->RegisterManagedOverrides (measure_cb, arrange_cb, get_default_template_cb, loaded_cb);
}


void
framework_element_set_default_style (FrameworkElement *instance, Style *value)
{
	if (instance == NULL)
		return;
	
	instance->SetDefaultStyle (value);
}


void
framework_element_set_logical_parent (FrameworkElement *instance, DependencyObject *logical_parent, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called framework_element_set_logical_parent () with error == NULL.");
	instance->SetLogicalParent (logical_parent, error);
}


/**
 * FrameworkTemplate
 **/
FrameworkTemplate *
framework_template_new (void)
{
	return new FrameworkTemplate ();
}


DependencyObject *
framework_template_get_visual_tree (FrameworkTemplate *instance, FrameworkElement *templateBindingSource)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetVisualTree (templateBindingSource);
}


/**
 * GeneralTransform
 **/
GeneralTransform *
general_transform_new (void)
{
	return new GeneralTransform ();
}


Matrix *
general_transform_get_matrix (GeneralTransform *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetMatrix ();
}


/**
 * Geometry
 **/
Geometry *
geometry_new (void)
{
	return new Geometry ();
}


Rect
geometry_get_bounds (Geometry *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (Rect) 0;
	
	return instance->GetBounds ();
}


/**
 * GeometryCollection
 **/
GeometryCollection *
geometry_collection_new (void)
{
	return new GeometryCollection ();
}


/**
 * GeometryGroup
 **/
GeometryGroup *
geometry_group_new (void)
{
	return new GeometryGroup ();
}


/**
 * Glyphs
 **/
Glyphs *
glyphs_new (void)
{
	return new Glyphs ();
}


/**
 * GradientBrush
 **/
GradientBrush *
gradient_brush_new (void)
{
	return new GradientBrush ();
}


/**
 * GradientStop
 **/
GradientStop *
gradient_stop_new (void)
{
	return new GradientStop ();
}


/**
 * GradientStopCollection
 **/
GradientStopCollection *
gradient_stop_collection_new (void)
{
	return new GradientStopCollection ();
}


/**
 * Grid
 **/
Grid *
grid_new (void)
{
	return new Grid ();
}


/**
 * HitTestCollection
 **/
HitTestCollection *
hit_test_collection_new (void)
{
	return new HitTestCollection ();
}


/**
 * Icon
 **/
Icon *
icon_new (void)
{
	return new Icon ();
}


/**
 * IconCollection
 **/
IconCollection *
icon_collection_new (void)
{
	return new IconCollection ();
}


/**
 * Image
 **/
Image *
image_new (void)
{
	return new Image ();
}


void
image_set_source (Image *instance, ImageSource *source)
{
	if (instance == NULL)
		return;
	
	instance->SetSource (source);
}


/**
 * ImageBrush
 **/
ImageBrush *
image_brush_new (void)
{
	return new ImageBrush ();
}


/**
 * ImageSource
 **/
ImageSource *
image_source_new (void)
{
	return new ImageSource ();
}


/**
 * IMediaDecoder
 **/
void
imedia_decoder_report_decode_frame_completed (IMediaDecoder *instance, MediaFrame *frame)
{
	if (instance == NULL)
		return;
	
	instance->ReportDecodeFrameCompleted (frame);
}


void
imedia_decoder_report_open_decoder_completed (IMediaDecoder *instance)
{
	if (instance == NULL)
		return;
	
	instance->ReportOpenDecoderCompleted ();
}


void
imedia_decoder_set_pixel_format (IMediaDecoder *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetPixelFormat ((MoonPixelFormat) value);
}


/**
 * IMediaDemuxer
 **/
void
imedia_demuxer_report_get_diagnostic_completed (IMediaDemuxer *instance, int diagnosticKind, gint64 diagnosticValue)
{
	if (instance == NULL)
		return;
	
	instance->ReportGetDiagnosticCompleted ((MediaStreamSourceDiagnosticKind) diagnosticKind, diagnosticValue);
}


void
imedia_demuxer_report_get_frame_completed (IMediaDemuxer *instance, MediaFrame *frame)
{
	if (instance == NULL)
		return;
	
	instance->ReportGetFrameCompleted (frame);
}


void
imedia_demuxer_report_get_frame_progress (IMediaDemuxer *instance, double bufferingProgress)
{
	if (instance == NULL)
		return;
	
	instance->ReportGetFrameProgress (bufferingProgress);
}


void
imedia_demuxer_report_open_demuxer_completed (IMediaDemuxer *instance)
{
	if (instance == NULL)
		return;
	
	instance->ReportOpenDemuxerCompleted ();
}


void
imedia_demuxer_report_seek_completed (IMediaDemuxer *instance, guint64 pts)
{
	if (instance == NULL)
		return;
	
	instance->ReportSeekCompleted (pts);
}


void
imedia_demuxer_report_switch_media_stream_completed (IMediaDemuxer *instance, IMediaStream *stream)
{
	if (instance == NULL)
		return;
	
	instance->ReportSwitchMediaStreamCompleted (stream);
}


void
imedia_demuxer_set_is_drm (IMediaDemuxer *instance, bool value)
{
	if (instance == NULL)
		return;
	
	instance->SetIsDrm (value);
}


/**
 * IMediaObject
 **/
Media *
imedia_object_get_media_reffed (IMediaObject *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetMediaReffed ();
}


void
imedia_object_report_error_occurred (IMediaObject *instance, const char *message)
{
	if (instance == NULL)
		return;
	
	instance->ReportErrorOccurred (message);
}


/**
 * IMediaStream
 **/
const char *
imedia_stream_get_codec (IMediaStream *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetCodec ();
}


int
imedia_stream_get_codec_id (IMediaStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetCodecId ();
}


guint64
imedia_stream_get_duration (IMediaStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (guint64) 0;
	
	return instance->GetDuration ();
}


void *
imedia_stream_get_extra_data (IMediaStream *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetExtraData ();
}


int
imedia_stream_get_extra_data_size (IMediaStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetExtraDataSize ();
}


int
imedia_stream_get_stream_type (IMediaStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (MediaStreamType) 0;
	
	return instance->GetStreamType ();
}


void
imedia_stream_set_codec_id (IMediaStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetCodecId (value);
}


void
imedia_stream_set_duration (IMediaStream *instance, guint64 value)
{
	if (instance == NULL)
		return;
	
	instance->SetDuration (value);
}


void
imedia_stream_set_extra_data (IMediaStream *instance, void *value)
{
	if (instance == NULL)
		return;
	
	instance->SetExtraData (value);
}


void
imedia_stream_set_extra_data_size (IMediaStream *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetExtraDataSize (value);
}


/**
 * InkPresenter
 **/
InkPresenter *
ink_presenter_new (void)
{
	return new InkPresenter ();
}


/**
 * Inline
 **/
Inline *
inline_new (void)
{
	return new Inline ();
}


/**
 * InlineCollection
 **/
InlineCollection *
inline_collection_new (void)
{
	return new InlineCollection ();
}


/**
 * InputMethod
 **/
InputMethod *
input_method_new (void)
{
	return new InputMethod ();
}


/**
 * ItemCollection
 **/
ItemCollection *
item_collection_new (void)
{
	return new ItemCollection ();
}


/**
 * Keyboard
 **/
int
keyboard_get_modifiers (void)
{
	return Keyboard::GetModifiers ();
}


/**
 * KeyEventArgs
 **/
int
key_event_args_get_key (KeyEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetKey ();
}


int
key_event_args_get_platform_key_code (KeyEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetPlatformKeyCode ();
}


KeyEventArgs *
key_event_args_new (void)
{
	return new KeyEventArgs ();
}


/**
 * KeyFrameCollection
 **/
KeyFrameCollection *
key_frame_collection_new (void)
{
	return new KeyFrameCollection ();
}


/**
 * KeySpline
 **/
KeySpline *
key_spline_new (void)
{
	return new KeySpline ();
}


/**
 * Line
 **/
Line *
line_new (void)
{
	return new Line ();
}


/**
 * LinearColorKeyFrame
 **/
LinearColorKeyFrame *
linear_color_key_frame_new (void)
{
	return new LinearColorKeyFrame ();
}


/**
 * LinearDoubleKeyFrame
 **/
LinearDoubleKeyFrame *
linear_double_key_frame_new (void)
{
	return new LinearDoubleKeyFrame ();
}


/**
 * LinearGradientBrush
 **/
LinearGradientBrush *
linear_gradient_brush_new (void)
{
	return new LinearGradientBrush ();
}


/**
 * LinearPointKeyFrame
 **/
LinearPointKeyFrame *
linear_point_key_frame_new (void)
{
	return new LinearPointKeyFrame ();
}


/**
 * LineBreak
 **/
LineBreak *
line_break_new (void)
{
	return new LineBreak ();
}


/**
 * LineGeometry
 **/
LineGeometry *
line_geometry_new (void)
{
	return new LineGeometry ();
}


/**
 * LineSegment
 **/
LineSegment *
line_segment_new (void)
{
	return new LineSegment ();
}


/**
 * LogReadyRoutedEventArgs
 **/
LogReadyRoutedEventArgs *
log_ready_routed_event_args_new (void)
{
	return new LogReadyRoutedEventArgs ();
}


/**
 * Matrix
 **/
cairo_matrix_t *
matrix_get_matrix_values (Matrix *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetMatrixValues ();
}


Matrix *
matrix_new (void)
{
	return new Matrix ();
}


/**
 * Matrix3D
 **/
gpointer
matrix3_d_get_matrix_values (Matrix3D *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (gpointer) 0;
	
	return instance->GetMatrixValues ();
}


Matrix3D *
matrix3_d_new (void)
{
	return new Matrix3D ();
}


/**
 * Matrix3DProjection
 **/
Matrix3DProjection *
matrix3_dprojection_new (void)
{
	return new Matrix3DProjection ();
}


/**
 * MatrixTransform
 **/
MatrixTransform *
matrix_transform_new (void)
{
	return new MatrixTransform ();
}


/**
 * Media
 **/
void
media_register_decoder (DecoderInfo *info)
{
	Media::RegisterDecoder (info);
}


/**
 * MediaAttribute
 **/
MediaAttribute *
media_attribute_new (void)
{
	return new MediaAttribute ();
}


/**
 * MediaAttributeCollection
 **/
MediaAttribute *
media_attribute_collection_get_item_by_name (MediaAttributeCollection *instance, const char *name)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetItemByName (name);
}


MediaAttributeCollection *
media_attribute_collection_new (void)
{
	return new MediaAttributeCollection ();
}


/**
 * MediaBase
 **/
MediaBase *
media_base_new (void)
{
	return new MediaBase ();
}


void
media_base_set_source (MediaBase *instance, const char *uri)
{
	if (instance == NULL)
		return;
	
	instance->SetSource (uri);
}


/**
 * MediaElement
 **/
MediaElement *
media_element_new (void)
{
	return new MediaElement ();
}


void
media_element_pause (MediaElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->Pause ();
}


void
media_element_play (MediaElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->Play ();
}


void
media_element_report_error_occurred (MediaElement *instance, const char *args)
{
	if (instance == NULL)
		return;
	
	instance->ReportErrorOccurred (args);
}


IMediaDemuxer *
media_element_set_demuxer_source (MediaElement *instance, void *context, CloseDemuxerCallback close_demuxer, GetDiagnosticAsyncCallback get_diagnostic, GetFrameAsyncCallback get_sample, OpenDemuxerAsyncCallback open_demuxer, SeekAsyncCallback seek, SwitchMediaStreamAsyncCallback switch_media_stream)
{
	if (instance == NULL)
		return NULL;
	
	return instance->SetDemuxerSource (context, close_demuxer, get_diagnostic, get_sample, open_demuxer, seek, switch_media_stream);
}


void
media_element_set_stream_source (MediaElement *instance, ManagedStreamCallbacks *stream)
{
	if (instance == NULL)
		return;
	
	instance->SetStreamSource (stream);
}


void
media_element_stop (MediaElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->Stop ();
}


/**
 * MediaFrame
 **/
void
media_frame_add_state (MediaFrame *instance, int state)
{
	if (instance == NULL)
		return;
	
	instance->AddState ((MediaFrameState) state);
}


guint8 *
media_frame_get_buffer (MediaFrame *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetBuffer ();
}


guint32
media_frame_get_buf_len (MediaFrame *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (guint32) 0;
	
	return instance->GetBufLen ();
}


gint32
media_frame_get_height (MediaFrame *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (gint32) 0;
	
	return instance->GetHeight ();
}


guint64
media_frame_get_pts (MediaFrame *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (guint64) 0;
	
	return instance->GetPts ();
}


gint32
media_frame_get_width (MediaFrame *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (gint32) 0;
	
	return instance->GetWidth ();
}


bool
media_frame_is_key_frame (MediaFrame *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->IsKeyFrame ();
}


MediaFrame *
media_frame_new (IMediaStream *stream, guint8 *buffer, guint32 buflen, guint64 pts, bool keyframe)
{
	return new MediaFrame (stream, buffer, buflen, pts, keyframe);
}


void
media_frame_set_buffer (MediaFrame *instance, guint8 *value)
{
	if (instance == NULL)
		return;
	
	instance->SetBuffer (value);
}


void
media_frame_set_buf_len (MediaFrame *instance, guint32 value)
{
	if (instance == NULL)
		return;
	
	instance->SetBufLen (value);
}


void
media_frame_set_data_stride (MediaFrame *instance, guint8 *a, guint8 *b, guint8 *c, guint8 *d)
{
	if (instance == NULL)
		return;
	
	instance->SetDataStride (a, b, c, d);
}


void
media_frame_set_decoder_specific_data (MediaFrame *instance, void *value)
{
	if (instance == NULL)
		return;
	
	instance->SetDecoderSpecificData (value);
}


void
media_frame_set_height (MediaFrame *instance, gint32 value)
{
	if (instance == NULL)
		return;
	
	instance->SetHeight (value);
}


void
media_frame_set_pts (MediaFrame *instance, guint64 value)
{
	if (instance == NULL)
		return;
	
	instance->SetPts (value);
}


void
media_frame_set_src_slide_h (MediaFrame *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetSrcSlideH (value);
}


void
media_frame_set_src_slide_y (MediaFrame *instance, int value)
{
	if (instance == NULL)
		return;
	
	instance->SetSrcSlideY (value);
}


void
media_frame_set_src_stride (MediaFrame *instance, int a, int b, int c, int d)
{
	if (instance == NULL)
		return;
	
	instance->SetSrcStride (a, b, c, d);
}


void
media_frame_set_width (MediaFrame *instance, gint32 value)
{
	if (instance == NULL)
		return;
	
	instance->SetWidth (value);
}


/**
 * MoonWindow
 **/
bool
moon_window_get_transparent (MoonWindow *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->GetTransparent ();
}


void
moon_window_set_transparent (MoonWindow *instance, bool flag)
{
	if (instance == NULL)
		return;
	
	instance->SetTransparent (flag);
}


/**
 * MoonWindowGtk
 **/
void *
moon_window_gtk_get_native_widget (MoonWindowGtk *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetNativeWidget ();
}


MoonWindowGtk *
moon_window_gtk_new (bool fullscreen, int w, int h, MoonWindow *parent, Surface *surface)
{
	return new MoonWindowGtk (fullscreen, w, h, parent, surface);
}


/**
 * MouseButtonEventArgs
 **/
MouseButtonEventArgs *
mouse_button_event_args_new (void)
{
	return new MouseButtonEventArgs ();
}


/**
 * MouseEventArgs
 **/
void
mouse_event_args_get_position (MouseEventArgs *instance, UIElement *relative_to, double *x, double *y)
{
	if (instance == NULL)
		return;
	
	instance->GetPosition (relative_to, x, y);
}


StylusInfo *
mouse_event_args_get_stylus_info (MouseEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetStylusInfo ();
}


StylusPointCollection *
mouse_event_args_get_stylus_points (MouseEventArgs *instance, UIElement *ink_presenter)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetStylusPoints (ink_presenter);
}


MouseEventArgs *
mouse_event_args_new (void)
{
	return new MouseEventArgs ();
}


/**
 * MouseWheelEventArgs
 **/
int
mouse_wheel_event_args_get_wheel_delta (MouseWheelEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetWheelDelta ();
}


MouseWheelEventArgs *
mouse_wheel_event_args_new (void)
{
	return new MouseWheelEventArgs ();
}


/**
 * MultiScaleImage
 **/
Point
multi_scale_image_element_to_logical_point (MultiScaleImage *instance, Point elementPoint)
{
	if (instance == NULL)
		return Point (0, 0);
	
	return instance->ElementToLogicalPoint (elementPoint);
}


void
multi_scale_image_emit_image_failed (MultiScaleImage *instance)
{
	if (instance == NULL)
		return;
	
	instance->EmitImageFailed ();
}


void
multi_scale_image_emit_image_open_failed (MultiScaleImage *instance)
{
	if (instance == NULL)
		return;
	
	instance->EmitImageOpenFailed ();
}


void
multi_scale_image_emit_motion_finished (MultiScaleImage *instance)
{
	if (instance == NULL)
		return;
	
	instance->EmitMotionFinished ();
}


void
multi_scale_image_handle_dz_parsed (MultiScaleImage *instance)
{
	if (instance == NULL)
		return;
	
	instance->HandleDzParsed ();
}


void
multi_scale_image_invalidate_tile_layer (MultiScaleImage *instance, int level, int tilePositionX, int tilePositionY, int tileLayer)
{
	if (instance == NULL)
		return;
	
	instance->InvalidateTileLayer (level, tilePositionX, tilePositionY, tileLayer);
}


Point
multi_scale_image_logical_to_element_point (MultiScaleImage *instance, Point logicalPoint)
{
	if (instance == NULL)
		return Point (0, 0);
	
	return instance->LogicalToElementPoint (logicalPoint);
}


MultiScaleImage *
multi_scale_image_new (void)
{
	return new MultiScaleImage ();
}


void
multi_scale_image_on_source_property_changed (MultiScaleImage *instance)
{
	if (instance == NULL)
		return;
	
	instance->OnSourcePropertyChanged ();
}


void
multi_scale_image_zoom_about_logical_point (MultiScaleImage *instance, double zoomIncrementFactor, double zoomCenterLogicalX, double zoomCenterLogicalY)
{
	if (instance == NULL)
		return;
	
	instance->ZoomAboutLogicalPoint (zoomIncrementFactor, zoomCenterLogicalX, zoomCenterLogicalY);
}


/**
 * MultiScaleSubImage
 **/
gint32
multi_scale_sub_image_get_zindex (MultiScaleSubImage *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (gint32) 0;
	
	return instance->GetZIndex ();
}


MultiScaleSubImage *
multi_scale_sub_image_new (void)
{
	return new MultiScaleSubImage ();
}


/**
 * MultiScaleSubImageCollection
 **/
MultiScaleSubImageCollection *
multi_scale_sub_image_collection_new (void)
{
	return new MultiScaleSubImageCollection ();
}


/**
 * MultiScaleTileSource
 **/
void
multi_scale_tile_source_invalidate_tile_layer (MultiScaleTileSource *instance, int level, int tilePositionX, int tilePositionY, int tileLayer)
{
	if (instance == NULL)
		return;
	
	instance->InvalidateTileLayer (level, tilePositionX, tilePositionY, tileLayer);
}


MultiScaleTileSource *
multi_scale_tile_source_new (void)
{
	return new MultiScaleTileSource ();
}


void
multi_scale_tile_source_set_image_uri_func (MultiScaleTileSource *instance, get_image_uri_func func)
{
	if (instance == NULL)
		return;
	
	instance->set_image_uri_func (func);
}


/**
 * NameScope
 **/
NameScope *
name_scope_new (void)
{
	return new NameScope ();
}


/**
 * ObjectAnimationUsingKeyFrames
 **/
ObjectAnimationUsingKeyFrames *
object_animation_using_key_frames_new (void)
{
	return new ObjectAnimationUsingKeyFrames ();
}


/**
 * ObjectKeyFrame
 **/
ObjectKeyFrame *
object_key_frame_new (void)
{
	return new ObjectKeyFrame ();
}


/**
 * ObjectKeyFrameCollection
 **/
ObjectKeyFrameCollection *
object_key_frame_collection_new (void)
{
	return new ObjectKeyFrameCollection ();
}


/**
 * OutOfBrowserSettings
 **/
OutOfBrowserSettings *
out_of_browser_settings_new (void)
{
	return new OutOfBrowserSettings ();
}


/**
 * Panel
 **/
Panel *
panel_new (void)
{
	return new Panel ();
}


/**
 * ParallelTimeline
 **/
ParallelTimeline *
parallel_timeline_new (void)
{
	return new ParallelTimeline ();
}


/**
 * PasswordBox
 **/
PasswordBox *
password_box_new (void)
{
	return new PasswordBox ();
}


/**
 * Path
 **/
Path *
path_new (void)
{
	return new Path ();
}


/**
 * PathFigure
 **/
PathFigure *
path_figure_new (void)
{
	return new PathFigure ();
}


/**
 * PathFigureCollection
 **/
PathFigureCollection *
path_figure_collection_new (void)
{
	return new PathFigureCollection ();
}


/**
 * PathGeometry
 **/
PathGeometry *
path_geometry_new (void)
{
	return new PathGeometry ();
}


/**
 * PathSegment
 **/
PathSegment *
path_segment_new (void)
{
	return new PathSegment ();
}


/**
 * PathSegmentCollection
 **/
PathSegmentCollection *
path_segment_collection_new (void)
{
	return new PathSegmentCollection ();
}


/**
 * PixelShader
 **/
PixelShader *
pixel_shader_new (void)
{
	return new PixelShader ();
}


/**
 * PlaneProjection
 **/
PlaneProjection *
plane_projection_new (void)
{
	return new PlaneProjection ();
}


/**
 * PointAnimation
 **/
PointAnimation *
point_animation_new (void)
{
	return new PointAnimation ();
}


/**
 * PointAnimationUsingKeyFrames
 **/
PointAnimationUsingKeyFrames *
point_animation_using_key_frames_new (void)
{
	return new PointAnimationUsingKeyFrames ();
}


/**
 * PointCollection
 **/
PointCollection *
point_collection_new (void)
{
	return new PointCollection ();
}


/**
 * PointKeyFrame
 **/
PointKeyFrame *
point_key_frame_new (void)
{
	return new PointKeyFrame ();
}


/**
 * PointKeyFrameCollection
 **/
PointKeyFrameCollection *
point_key_frame_collection_new (void)
{
	return new PointKeyFrameCollection ();
}


/**
 * PolyBezierSegment
 **/
PolyBezierSegment *
poly_bezier_segment_new (void)
{
	return new PolyBezierSegment ();
}


void
poly_bezier_segment_set_points (PolyBezierSegment *instance, PointCollection *points)
{
	if (instance == NULL)
		return;
	
	instance->SetPoints (points);
}


/**
 * Polygon
 **/
Polygon *
polygon_new (void)
{
	return new Polygon ();
}


/**
 * Polyline
 **/
Polyline *
polyline_new (void)
{
	return new Polyline ();
}


/**
 * PolyLineSegment
 **/
PolyLineSegment *
poly_line_segment_new (void)
{
	return new PolyLineSegment ();
}


/**
 * PolyQuadraticBezierSegment
 **/
PolyQuadraticBezierSegment *
poly_quadratic_bezier_segment_new (void)
{
	return new PolyQuadraticBezierSegment ();
}


/**
 * Popup
 **/
Popup *
popup_new (void)
{
	return new Popup ();
}


/**
 * PowerEase
 **/
double
power_ease_ease_in_core (PowerEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


PowerEase *
power_ease_new (void)
{
	return new PowerEase ();
}


/**
 * Projection
 **/
Projection *
projection_new (void)
{
	return new Projection ();
}


/**
 * PropertyChangedEventArgs
 **/
int
property_changed_event_args_get_id (PropertyChangedEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetId ();
}


Value *
property_changed_event_args_get_new_value (PropertyChangedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetNewValue ();
}


Value *
property_changed_event_args_get_old_value (PropertyChangedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetOldValue ();
}


DependencyProperty *
property_changed_event_args_get_property (PropertyChangedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetProperty ();
}


/**
 * QuadraticBezierSegment
 **/
QuadraticBezierSegment *
quadratic_bezier_segment_new (void)
{
	return new QuadraticBezierSegment ();
}


/**
 * QuadraticEase
 **/
double
quadratic_ease_ease_in_core (QuadraticEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


QuadraticEase *
quadratic_ease_new (void)
{
	return new QuadraticEase ();
}


/**
 * QuarticEase
 **/
double
quartic_ease_ease_in_core (QuarticEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


QuarticEase *
quartic_ease_new (void)
{
	return new QuarticEase ();
}


/**
 * QuinticEase
 **/
double
quintic_ease_ease_in_core (QuinticEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


QuinticEase *
quintic_ease_new (void)
{
	return new QuinticEase ();
}


/**
 * RadialGradientBrush
 **/
RadialGradientBrush *
radial_gradient_brush_new (void)
{
	return new RadialGradientBrush ();
}


/**
 * Rectangle
 **/
Rectangle *
rectangle_new (void)
{
	return new Rectangle ();
}


/**
 * RectangleGeometry
 **/
RectangleGeometry *
rectangle_geometry_new (void)
{
	return new RectangleGeometry ();
}


/**
 * RenderingEventArgs
 **/
TimeSpan
rendering_event_args_get_rendering_time (RenderingEventArgs *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (TimeSpan) 0;
	
	return instance->GetRenderingTime ();
}


/**
 * ResourceDictionary
 **/
bool
resource_dictionary_add_with_error (ResourceDictionary *instance, const char *key, Value *value, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called resource_dictionary_add_with_error () with error == NULL.");
	return instance->AddWithError (key, value, error);
}


bool
resource_dictionary_clear (ResourceDictionary *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->Clear ();
}


bool
resource_dictionary_contains_key (ResourceDictionary *instance, const char *key)
{
	if (instance == NULL)
		return false;
	
	return instance->ContainsKey (key);
}


Value *
resource_dictionary_get (ResourceDictionary *instance, const char *key, bool *exists)
{
	if (instance == NULL)
		return NULL;
	
	return instance->Get (key, exists);
}


bool
resource_dictionary_remove (ResourceDictionary *instance, const char *key)
{
	if (instance == NULL)
		return false;
	
	return instance->Remove (key);
}


ResourceDictionary *
resource_dictionary_new (void)
{
	return new ResourceDictionary ();
}


bool
resource_dictionary_set (ResourceDictionary *instance, const char *key, Value *value)
{
	if (instance == NULL)
		return false;
	
	return instance->Set (key, value);
}


/**
 * ResourceDictionaryCollection
 **/
ResourceDictionaryCollection *
resource_dictionary_collection_new (void)
{
	return new ResourceDictionaryCollection ();
}


/**
 * ResourceDictionaryIterator
 **/
const char *
resource_dictionary_iterator_get_current_key (ResourceDictionaryIterator *instance, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called resource_dictionary_iterator_get_current_key () with error == NULL.");
	return instance->GetCurrentKey (error);
}


/**
 * RotateTransform
 **/
RotateTransform *
rotate_transform_new (void)
{
	return new RotateTransform ();
}


/**
 * RoutedEventArgs
 **/
bool
routed_event_args_get_handled (RoutedEventArgs *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->GetHandled ();
}


DependencyObject *
routed_event_args_get_source (RoutedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetSource ();
}


RoutedEventArgs *
routed_event_args_new (void)
{
	return new RoutedEventArgs ();
}


void
routed_event_args_set_handled (RoutedEventArgs *instance, bool handled)
{
	if (instance == NULL)
		return;
	
	instance->SetHandled (handled);
}


void
routed_event_args_set_source (RoutedEventArgs *instance, DependencyObject *el)
{
	if (instance == NULL)
		return;
	
	instance->SetSource (el);
}


/**
 * RowDefinition
 **/
RowDefinition *
row_definition_new (void)
{
	return new RowDefinition ();
}


/**
 * RowDefinitionCollection
 **/
RowDefinitionCollection *
row_definition_collection_new (void)
{
	return new RowDefinitionCollection ();
}


/**
 * Run
 **/
Run *
run_new (void)
{
	return new Run ();
}


/**
 * ScaleTransform
 **/
ScaleTransform *
scale_transform_new (void)
{
	return new ScaleTransform ();
}


/**
 * Setter
 **/
Setter *
setter_new (void)
{
	return new Setter ();
}


/**
 * SetterBase
 **/
SetterBase *
setter_base_new (void)
{
	return new SetterBase ();
}


/**
 * SetterBaseCollection
 **/
SetterBaseCollection *
setter_base_collection_new (void)
{
	return new SetterBaseCollection ();
}


/**
 * ShaderEffect
 **/
ShaderEffect *
shader_effect_new (void)
{
	return new ShaderEffect ();
}


/**
 * Shape
 **/
Transform *
shape_get_geometry_transform (Shape *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetGeometryTransform ();
}


Shape *
shape_new (void)
{
	return new Shape ();
}


/**
 * SineEase
 **/
double
sine_ease_ease_in_core (SineEase *instance, double normalizedTime)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->EaseInCore (normalizedTime);
}


SineEase *
sine_ease_new (void)
{
	return new SineEase ();
}


/**
 * SizeChangedEventArgs
 **/
SizeChangedEventArgs *
size_changed_event_args_new (void)
{
	return new SizeChangedEventArgs ();
}


/**
 * SkewTransform
 **/
SkewTransform *
skew_transform_new (void)
{
	return new SkewTransform ();
}


/**
 * SolidColorBrush
 **/
SolidColorBrush *
solid_color_brush_new (void)
{
	return new SolidColorBrush ();
}


/**
 * SplineColorKeyFrame
 **/
SplineColorKeyFrame *
spline_color_key_frame_new (void)
{
	return new SplineColorKeyFrame ();
}


/**
 * SplineDoubleKeyFrame
 **/
SplineDoubleKeyFrame *
spline_double_key_frame_new (void)
{
	return new SplineDoubleKeyFrame ();
}


/**
 * SplinePointKeyFrame
 **/
SplinePointKeyFrame *
spline_point_key_frame_new (void)
{
	return new SplinePointKeyFrame ();
}


/**
 * Storyboard
 **/
bool
storyboard_begin_with_error (Storyboard *instance, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_begin_with_error () with error == NULL.");
	return instance->BeginWithError (error);
}


int
storyboard_get_current_state (Storyboard *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetCurrentState ();
}


TimeSpan
storyboard_get_current_time (Storyboard *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (TimeSpan) 0;
	
	return instance->GetCurrentTime ();
}


DependencyProperty *
storyboard_get_target_dependency_property (Storyboard *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTargetDependencyProperty ();
}


void
storyboard_pause_with_error (Storyboard *instance, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_pause_with_error () with error == NULL.");
	instance->PauseWithError (error);
}


void
storyboard_resume_with_error (Storyboard *instance, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_resume_with_error () with error == NULL.");
	instance->ResumeWithError (error);
}


void
storyboard_seek_aligned_to_last_tick_with_error (Storyboard *instance, TimeSpan timespan, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_seek_aligned_to_last_tick_with_error () with error == NULL.");
	instance->SeekAlignedToLastTickWithError (timespan, error);
}


void
storyboard_seek_with_error (Storyboard *instance, TimeSpan timespan, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_seek_with_error () with error == NULL.");
	instance->SeekWithError (timespan, error);
}


void
storyboard_skip_to_fill_with_error (Storyboard *instance, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_skip_to_fill_with_error () with error == NULL.");
	instance->SkipToFillWithError (error);
}


void
storyboard_stop_with_error (Storyboard *instance, MoonError *error)
{
	if (instance == NULL)
		return;
	
	if (error == NULL)
		g_warning ("Moonlight: Called storyboard_stop_with_error () with error == NULL.");
	instance->StopWithError (error);
}


Storyboard *
storyboard_new (void)
{
	return new Storyboard ();
}


/**
 * Stroke
 **/
bool
stroke_hit_test (Stroke *instance, StylusPointCollection *stylusPoints)
{
	if (instance == NULL)
		return false;
	
	return instance->HitTest (stylusPoints);
}


Stroke *
stroke_new (void)
{
	return new Stroke ();
}


/**
 * StrokeCollection
 **/
StrokeCollection *
stroke_collection_hit_test (StrokeCollection *instance, StylusPointCollection *stylusPoints)
{
	if (instance == NULL)
		return NULL;
	
	return instance->HitTest (stylusPoints);
}


StrokeCollection *
stroke_collection_new (void)
{
	return new StrokeCollection ();
}


/**
 * Style
 **/
void
style_seal (Style *instance)
{
	if (instance == NULL)
		return;
	
	instance->Seal ();
}


Style *
style_new (void)
{
	return new Style ();
}


/**
 * StylusInfo
 **/
StylusInfo *
stylus_info_new (void)
{
	return new StylusInfo ();
}


/**
 * StylusPoint
 **/
double
stylus_point_get_pressure_factor (StylusPoint *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetPressureFactor ();
}


double
stylus_point_get_x (StylusPoint *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetX ();
}


double
stylus_point_get_y (StylusPoint *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetY ();
}


void
stylus_point_set_pressure_factor (StylusPoint *instance, double factor)
{
	if (instance == NULL)
		return;
	
	instance->SetPressureFactor (factor);
}


void
stylus_point_set_x (StylusPoint *instance, double x)
{
	if (instance == NULL)
		return;
	
	instance->SetX (x);
}


void
stylus_point_set_y (StylusPoint *instance, double y)
{
	if (instance == NULL)
		return;
	
	instance->SetY (y);
}


StylusPoint *
stylus_point_new (void)
{
	return new StylusPoint ();
}


/**
 * StylusPointCollection
 **/
double
stylus_point_collection_add_stylus_points (StylusPointCollection *instance, StylusPointCollection *stylusPointCollection)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->AddStylusPoints (stylusPointCollection);
}


StylusPointCollection *
stylus_point_collection_new (void)
{
	return new StylusPointCollection ();
}


/**
 * Surface
 **/
void
surface_attach (Surface *instance, UIElement *toplevel)
{
	if (instance == NULL)
		return;
	
	instance->Attach (toplevel);
}


Downloader *
surface_create_downloader (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->CreateDownloader ();
}


void
surface_emit_error (Surface *instance, int number, int code, const char *message)
{
	if (instance == NULL)
		return;
	
	instance->EmitError (number, code, message);
}


Color *
surface_get_background_color (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetBackgroundColor ();
}


UIElement *
surface_get_focused_element (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetFocusedElement ();
}


bool
surface_get_full_screen (Surface *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->GetFullScreen ();
}


TimeManager *
surface_get_time_manager (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTimeManager ();
}


UIElement *
surface_get_toplevel (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetToplevel ();
}


int
surface_get_user_initiated_counter (Surface *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetUserInitiatedCounter ();
}


MoonWindow *
surface_get_window (Surface *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetWindow ();
}


double
surface_get_zoom_factor (Surface *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (double) 0;
	
	return instance->GetZoomFactor ();
}


bool
surface_in_main_thread (void)
{
	return Surface::InMainThread ();
}


bool
surface_is_loaded (Surface *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->IsLoaded ();
}


bool
surface_is_user_initiated_event (Surface *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->IsUserInitiatedEvent ();
}


bool
surface_is_version_supported (const char *version)
{
	return Surface::IsVersionSupported (version);
}


void
surface_paint (Surface *instance, cairo_t *ctx, int x, int y, int width, int height)
{
	if (instance == NULL)
		return;
	
	instance->Paint (ctx, x, y, width, height);
}


void
surface_resize (Surface *instance, int width, int height)
{
	if (instance == NULL)
		return;
	
	instance->Resize (width, height);
}


void
surface_set_full_screen (Surface *instance, bool value)
{
	if (instance == NULL)
		return;
	
	instance->SetFullScreen (value);
}


Surface *
surface_new (MoonWindow *window)
{
	return new Surface (window);
}


/**
 * TabNavigationWalker
 **/
bool
tab_navigation_walker_focus (UIElement *element, bool forwards)
{
	return TabNavigationWalker::Focus (element, forwards);
}


/**
 * TextBlock
 **/
TextBlock *
text_block_new (void)
{
	return new TextBlock ();
}


/**
 * TextBox
 **/
TextBox *
text_box_new (void)
{
	return new TextBox ();
}


/**
 * TextBoxBase
 **/
void
text_box_base_on_got_focus (TextBoxBase *instance, RoutedEventArgs *args)
{
	if (instance == NULL)
		return;
	
	instance->OnGotFocus (args);
}


void
text_box_base_on_key_down (TextBoxBase *instance, KeyEventArgs *args)
{
	if (instance == NULL)
		return;
	
	instance->OnKeyDown (args);
}


void
text_box_base_on_key_up (TextBoxBase *instance, KeyEventArgs *args)
{
	if (instance == NULL)
		return;
	
	instance->OnKeyUp (args);
}


void
text_box_base_on_lost_focus (TextBoxBase *instance, RoutedEventArgs *args)
{
	if (instance == NULL)
		return;
	
	instance->OnLostFocus (args);
}


void
text_box_base_on_mouse_left_button_down (TextBoxBase *instance, MouseButtonEventArgs *args)
{
	if (instance == NULL)
		return;
	
	instance->OnMouseLeftButtonDown (args);
}


void
text_box_base_on_mouse_left_button_up (TextBoxBase *instance, MouseButtonEventArgs *args)
{
	if (instance == NULL)
		return;
	
	instance->OnMouseLeftButtonUp (args);
}


void
text_box_base_on_mouse_move (TextBoxBase *instance, MouseEventArgs *args)
{
	if (instance == NULL)
		return;
	
	instance->OnMouseMove (args);
}


void
text_box_base_post_on_key_down (TextBoxBase *instance, KeyEventArgs *args)
{
	if (instance == NULL)
		return;
	
	instance->PostOnKeyDown (args);
}


void
text_box_base_select_all (TextBoxBase *instance)
{
	if (instance == NULL)
		return;
	
	instance->SelectAll ();
}


bool
text_box_base_select_with_error (TextBoxBase *instance, int start, int length, MoonError *error)
{
	if (instance == NULL)
		return false;
	
	if (error == NULL)
		g_warning ("Moonlight: Called text_box_base_select_with_error () with error == NULL.");
	return instance->SelectWithError (start, length, error);
}


/**
 * TextBoxView
 **/
TextBoxView *
text_box_view_new (void)
{
	return new TextBoxView ();
}


/**
 * TextChangedEventArgs
 **/
TextChangedEventArgs *
text_changed_event_args_new (void)
{
	return new TextChangedEventArgs ();
}


/**
 * TileBrush
 **/
TileBrush *
tile_brush_new (void)
{
	return new TileBrush ();
}


/**
 * Timeline
 **/
DependencyObject *
timeline_get_manual_target (Timeline *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetManualTarget ();
}


void
timeline_set_manual_target (Timeline *instance, DependencyObject *o)
{
	if (instance == NULL)
		return;
	
	instance->SetManualTarget (o);
}


Timeline *
timeline_new (void)
{
	return new Timeline ();
}


/**
 * TimelineCollection
 **/
TimelineCollection *
timeline_collection_new (void)
{
	return new TimelineCollection ();
}


/**
 * TimelineGroup
 **/
TimelineGroup *
timeline_group_new (void)
{
	return new TimelineGroup ();
}


/**
 * TimelineMarker
 **/
TimelineMarker *
timeline_marker_new (void)
{
	return new TimelineMarker ();
}


/**
 * TimelineMarkerCollection
 **/
TimelineMarkerCollection *
timeline_marker_collection_new (void)
{
	return new TimelineMarkerCollection ();
}


/**
 * TimelineMarkerRoutedEventArgs
 **/
TimelineMarker *
timeline_marker_routed_event_args_get_marker (TimelineMarkerRoutedEventArgs *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetMarker ();
}


TimelineMarkerRoutedEventArgs *
timeline_marker_routed_event_args_new (TimelineMarker *marker)
{
	return new TimelineMarkerRoutedEventArgs (marker);
}


/**
 * TimeManager
 **/
void
time_manager_add_dispatcher_call (TimeManager *instance, TickCallHandler handler, EventObject *tick_data)
{
	if (instance == NULL)
		return;
	
	instance->AddDispatcherCall (handler, tick_data);
}


void
time_manager_add_tick_call (TimeManager *instance, TickCallHandler handler, EventObject *tick_data)
{
	if (instance == NULL)
		return;
	
	instance->AddTickCall (handler, tick_data);
}


guint
time_manager_add_timeout (TimeManager *instance, gint priority, guint ms_interval, GSourceFunc func, gpointer timeout_data)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (guint) 0;
	
	return instance->AddTimeout (priority, ms_interval, func, timeout_data);
}


int
time_manager_get_maximum_refresh_rate (TimeManager *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetMaximumRefreshRate ();
}


void
time_manager_remove_tick_call (TimeManager *instance, TickCallHandler handler, EventObject *tick_data)
{
	if (instance == NULL)
		return;
	
	instance->RemoveTickCall (handler, tick_data);
}


void
time_manager_remove_timeout (TimeManager *instance, guint timeout_id)
{
	if (instance == NULL)
		return;
	
	instance->RemoveTimeout (timeout_id);
}


void
time_manager_set_maximum_refresh_rate (TimeManager *instance, int hz)
{
	if (instance == NULL)
		return;
	
	instance->SetMaximumRefreshRate (hz);
}


/**
 * TouchDevice
 **/
UIElement *
touch_device_get_directly_over (TouchDevice *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetDirectlyOver ();
}


int
touch_device_get_id (TouchDevice *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (int) 0;
	
	return instance->GetId ();
}


void
touch_device_set_directly_over (TouchDevice *instance, UIElement *element)
{
	if (instance == NULL)
		return;
	
	instance->SetDirectlyOver (element);
}


void
touch_device_set_id (TouchDevice *instance, int id)
{
	if (instance == NULL)
		return;
	
	instance->SetId (id);
}


TouchDevice *
touch_device_new (void)
{
	return new TouchDevice ();
}


/**
 * TouchPoint
 **/
int
touch_point_get_action (TouchPoint *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (TouchAction) 0;
	
	return instance->GetAction ();
}


Point *
touch_point_get_position (TouchPoint *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetPosition ();
}


Size *
touch_point_get_size (TouchPoint *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetSize ();
}


TouchDevice *
touch_point_get_touch_device (TouchPoint *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTouchDevice ();
}


void
touch_point_set_action (TouchPoint *instance, int action)
{
	if (instance == NULL)
		return;
	
	instance->SetAction ((TouchAction) action);
}


void
touch_point_set_position (TouchPoint *instance, Point *position)
{
	if (instance == NULL)
		return;
	
	instance->SetPosition (position);
}


void
touch_point_set_size (TouchPoint *instance, Size *size)
{
	if (instance == NULL)
		return;
	
	instance->SetSize (size);
}


void
touch_point_set_touch_device (TouchPoint *instance, TouchDevice *device)
{
	if (instance == NULL)
		return;
	
	instance->SetTouchDevice (device);
}


TouchPoint *
touch_point_new (void)
{
	return new TouchPoint ();
}


/**
 * TouchPointCollection
 **/
TouchPointCollection *
touch_point_collection_new (void)
{
	return new TouchPointCollection ();
}


/**
 * Transform
 **/
Transform *
transform_new (void)
{
	return new Transform ();
}


/**
 * TransformCollection
 **/
TransformCollection *
transform_collection_new (void)
{
	return new TransformCollection ();
}


/**
 * TransformGroup
 **/
TransformGroup *
transform_group_new (void)
{
	return new TransformGroup ();
}


/**
 * TranslateTransform
 **/
TranslateTransform *
translate_transform_new (void)
{
	return new TranslateTransform ();
}


/**
 * TriggerAction
 **/
void
trigger_action_fire (TriggerAction *instance)
{
	if (instance == NULL)
		return;
	
	instance->Fire ();
}


TriggerAction *
trigger_action_new (void)
{
	return new TriggerAction ();
}


/**
 * TriggerActionCollection
 **/
TriggerActionCollection *
trigger_action_collection_new (void)
{
	return new TriggerActionCollection ();
}


/**
 * TriggerBase
 **/
TriggerBase *
trigger_base_new (void)
{
	return new TriggerBase ();
}


/**
 * TriggerCollection
 **/
TriggerCollection *
trigger_collection_new (void)
{
	return new TriggerCollection ();
}


/**
 * Types
 **/
Type *
types_find (Types *instance, int type)
{
	if (instance == NULL)
		return NULL;
	
	return instance->Find ((Type::Kind) type);
}


int
types_register_type (Types *instance, const char *name, void *gc_handle, int parent, bool is_interface, bool ctor_visible, int *interfaces, int interface_count)
{
	if (instance == NULL)
		return Type::INVALID;
	
	return instance->RegisterType (name, gc_handle, (Type::Kind) parent, is_interface, ctor_visible, (Type::Kind*) interfaces, interface_count);
}


Types *
types_new (void)
{
	return new Types ();
}


/**
 * UIElement
 **/
void
uielement_arrange (UIElement *instance, Rect finalRect)
{
	if (instance == NULL)
		return;
	
	instance->Arrange (finalRect);
}


bool
uielement_capture_mouse (UIElement *instance)
{
	if (instance == NULL)
		return false;
	
	return instance->CaptureMouse ();
}


void
uielement_element_added (UIElement *instance, UIElement *obj)
{
	if (instance == NULL)
		return;
	
	instance->ElementAdded (obj);
}


void
uielement_element_removed (UIElement *instance, UIElement *obj)
{
	if (instance == NULL)
		return;
	
	instance->ElementRemoved (obj);
}


void
uielement_find_elements_in_host_coordinates_p (UIElement *instance, Point p, HitTestCollection *uielement_list)
{
	if (instance == NULL)
		return;
	
	instance->FindElementsInHostCoordinates_p (p, uielement_list);
}


void
uielement_find_elements_in_host_coordinates_r (UIElement *instance, Rect p, HitTestCollection *uielement_list)
{
	if (instance == NULL)
		return;
	
	instance->FindElementsInHostCoordinates_r (p, uielement_list);
}


bool
uielement_focus (UIElement *instance, bool recurse)
{
	if (instance == NULL)
		return false;
	
	return instance->Focus (recurse);
}


Size
uielement_get_desired_size (UIElement *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (Size) 0;
	
	return instance->GetDesiredSize ();
}


Size
uielement_get_render_size (UIElement *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (Size) 0;
	
	return instance->GetRenderSize ();
}


DependencyObject *
uielement_get_subtree_object (UIElement *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetSubtreeObject ();
}


GeneralTransform *
uielement_get_transform_to_uielement_with_error (UIElement *instance, UIElement *to_element, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called uielement_get_transform_to_uielement_with_error () with error == NULL.");
	return instance->GetTransformToUIElementWithError (to_element, error);
}


UIElement *
uielement_get_visual_parent (UIElement *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetVisualParent ();
}


void
uielement_invalidate (UIElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->Invalidate ();
}


void
uielement_invalidate_arrange (UIElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->InvalidateArrange ();
}


void
uielement_invalidate_measure (UIElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->InvalidateMeasure ();
}


void
uielement_measure (UIElement *instance, Size availableSize)
{
	if (instance == NULL)
		return;
	
	instance->Measure (availableSize);
}


void
uielement_release_mouse_capture (UIElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->ReleaseMouseCapture ();
}


void
uielement_set_subtree_object (UIElement *instance, DependencyObject *value)
{
	if (instance == NULL)
		return;
	
	instance->SetSubtreeObject (value);
}


void
uielement_update_layout (UIElement *instance)
{
	if (instance == NULL)
		return;
	
	instance->UpdateLayout ();
}


/**
 * UIElementCollection
 **/
UIElementCollection *
uielement_collection_new (void)
{
	return new UIElementCollection ();
}


/**
 * UnmanagedMatrix
 **/
UnmanagedMatrix *
unmanaged_matrix_new (void)
{
	return new UnmanagedMatrix ();
}


/**
 * UnmanagedMatrix3D
 **/
UnmanagedMatrix3D *
unmanaged_matrix3_d_new (void)
{
	return new UnmanagedMatrix3D ();
}


/**
 * Uri
 **/
bool
uri_equals (const Uri *left, const Uri *right)
{
	return Uri::Equals (left, right);
}


void
uri_free (Uri *instance)
{
	if (instance == NULL)
		return;
	
	instance->Free ();
}


guint
uri_get_hash_code (Uri *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (guint) 0;
	
	return instance->GetHashCode ();
}


bool
uri_parse (Uri *instance, const char *uri, bool allow_trailing_sep)
{
	if (instance == NULL)
		return false;
	
	return instance->Parse (uri, allow_trailing_sep);
}


/**
 * UserControl
 **/
UserControl *
user_control_new (void)
{
	return new UserControl ();
}


/**
 * VideoBrush
 **/
void
video_brush_set_source (VideoBrush *instance, MediaElement *source)
{
	if (instance == NULL)
		return;
	
	instance->SetSource (source);
}


VideoBrush *
video_brush_new (void)
{
	return new VideoBrush ();
}


/**
 * VideoStream
 **/
guint32
video_stream_get_height (VideoStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (guint32) 0;
	
	return instance->GetHeight ();
}


guint32
video_stream_get_width (VideoStream *instance)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (guint32) 0;
	
	return instance->GetWidth ();
}


VideoStream *
video_stream_new (Media *media, int codec_id, guint32 width, guint32 height, guint64 duration, gpointer extra_data, guint32 extra_data_size)
{
	return new VideoStream (media, codec_id, width, height, duration, extra_data, extra_data_size);
}


/**
 * VisualBrush
 **/
VisualBrush *
visual_brush_new (void)
{
	return new VisualBrush ();
}


/**
 * WindowSettings
 **/
WindowSettings *
window_settings_new (void)
{
	return new WindowSettings ();
}


/**
 * WriteableBitmap
 **/
gpointer
writeable_bitmap_initialize_from_bitmap_source (WriteableBitmap *instance, BitmapSource *source)
{
	if (instance == NULL)
		// Need to find a proper way to get the default value for the specified type and return that if instance is NULL.
		return (gpointer) 0;
	
	return instance->InitializeFromBitmapSource (source);
}


void
writeable_bitmap_lock (WriteableBitmap *instance)
{
	if (instance == NULL)
		return;
	
	instance->Lock ();
}


void
writeable_bitmap_render (WriteableBitmap *instance, UIElement *element, Transform *transform)
{
	if (instance == NULL)
		return;
	
	instance->Render (element, transform);
}


void
writeable_bitmap_unlock (WriteableBitmap *instance)
{
	if (instance == NULL)
		return;
	
	instance->Unlock ();
}


WriteableBitmap *
writeable_bitmap_new (void)
{
	return new WriteableBitmap ();
}


/**
 * XamlContext
 **/
DependencyObject *
xaml_context_get_template_binding_source (XamlContext *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetTemplateBindingSource ();
}


/**
 * XamlLoader
 **/
Value *
xaml_loader_create_from_file_with_error (XamlLoader *instance, const char *xaml, bool create_namescope, int *element_type, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called xaml_loader_create_from_file_with_error () with error == NULL.");
	return instance->CreateFromFileWithError (xaml, create_namescope, (Type::Kind*) element_type, error);
}


Value *
xaml_loader_create_from_string_with_error (XamlLoader *instance, const char *xaml, bool create_namescope, int *element_type, int flags, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called xaml_loader_create_from_string_with_error () with error == NULL.");
	return instance->CreateFromStringWithError (xaml, create_namescope, (Type::Kind*) element_type, flags, error);
}


XamlContext *
xaml_loader_get_context (XamlLoader *instance)
{
	if (instance == NULL)
		return NULL;
	
	return instance->GetContext ();
}


Value *
xaml_loader_hydrate_from_string_with_error (XamlLoader *instance, const char *xaml, Value *obj, bool create_namescope, int *element_type, int flags, MoonError *error)
{
	if (instance == NULL)
		return NULL;
	
	if (error == NULL)
		g_warning ("Moonlight: Called xaml_loader_hydrate_from_string_with_error () with error == NULL.");
	return instance->HydrateFromStringWithError (xaml, obj, create_namescope, (Type::Kind*) element_type, flags, error);
}


/**
 * Xap
 **/
char *
xap_unpack (const char *fname)
{
	return Xap::Unpack (fname);
}


